#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include <doctest.h>
#include <cpp_utils/cpp_utils.h>

#include <boost/range/combine.hpp>
#include <boost/range/algorithm_ext/insert.hpp>

#include <vector>
#include <unordered_set>
#include <iterator>
#include <tuple>

#include <iostream>

using doctest::Approx;
using namespace cpp_utils;

TEST_CASE("Test range function")
{
    GIVEN("An initial start, end, and stepsize")
    {
        auto start = int64_t{3};
        auto end = uint32_t{11};
        auto step = 2;
        WHEN("Storing the generated values in a vector")
        {
            auto values_rng = std::vector<
                                    std::iterator_traits<
                                        decltype(
                                            std::begin(range(start, end, step))
                                        )
                                    >::value_type
                              >{};
            for(auto i: range(start, end, step))
            {
                values_rng.push_back(i);
            }
            THEN("They must be equal to the numbers generated by constructing a "
                  "for loop manually")
            {
                auto values_man = std::vector<int64_t>{};
                for(auto i = int64_t{start}; i < int64_t{end}; i += step)
                {
                    values_man.push_back(i);
                }
                static_assert(std::is_same<decltype(values_rng)::value_type,
                                           int64_t>::value,
                              "The type of the generated range must equal the "
                              "larger type of start and end");
                REQUIRE(values_rng == values_man);
            }
        }
    }
    GIVEN("A range size")
    {
        auto end = int64_t{57};
        WHEN("Comparing them to the range with start=0 and step=1")
        {
            THEN("The results must be the same")
            {
                for(auto i: boost::range::combine(range(end), range(0, end, 1)))
                {
                    static_assert(
                            std::is_same<
                                std::decay_t<
                                    decltype(std::get<0>(i))
                                >,
                                int64_t
                            >::value,
                            "Type of the range must be same as type of end");
                    REQUIRE(std::get<0>(i) == std::get<1>(i));
                }

                // // C++17:
                // for(auto [i0, i1]: boost::range::combine(range(end), range(0, end, 1)))
                // {
                //     static_assert(
                //             std::is_same<
                //                 std::decay_t<decltype(i0)>,
                //                 int64_t
                //             >::value,
                //             "Type of the range must be same as type of end");
                //     REQUIRE(i0 == i1);
                // }
            }
        }
    }
}

TEST_CASE("Test remove_if")
{
    GIVEN("An unordered set with a number of odd and even numbers")
    {
        auto uset = std::unordered_set<int32_t>{};
        boost::insert(uset, range(10));

        WHEN("We use erase_if to remove all odd numbers")
        {
            remove_if(uset, [](int32_t i){ return i%2==1; });

            THEN("Only the even numbers must remain in the set")
            {
                for(auto i: range(10))
                {
                    if(i%2==1)
                    {
                        REQUIRE(uset.count(i) == 0);
                    }
                    else
                    {
                        REQUIRE(uset.count(i) == 1);
                    }
                }
            }
        }
    }
}
