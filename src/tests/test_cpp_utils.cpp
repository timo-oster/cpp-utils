#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include <doctest.h>
#include <cpp_utils/cpp_utils.h>

#include <boost/range/combine.hpp>
#include <boost/range/algorithm_ext/insert.hpp>

#include <vector>
#include <unordered_set>
#include <iterator>
#include <tuple>

#include <iostream>

using doctest::Approx;
using namespace cpp_utils;

TEST_CASE("Test range function")
{
    GIVEN("An initial start, end, and stepsize")
    {
        auto start = int64_t{3};
        auto end = uint32_t{11};
        auto step = 2;
        WHEN("Storing the generated values in a vector")
        {
            auto values_rng = std::vector<
                                    std::iterator_traits<
                                        decltype(
                                            std::begin(range(start, end, step))
                                        )
                                    >::value_type
                              >{};
            for(auto i: range(start, end, step))
            {
                values_rng.push_back(i);
            }
            THEN("They must be equal to the numbers generated by constructing a "
                  "for loop manually")
            {
                auto values_man = std::vector<int64_t>{};
                for(auto i = int64_t{start}; i < int64_t{end}; i += step)
                {
                    values_man.push_back(i);
                }
                static_assert(std::is_same<decltype(values_rng)::value_type,
                                           int64_t>::value,
                              "The type of the generated range must equal the "
                              "larger type of start and end");
                REQUIRE(values_rng == values_man);
            }
        }
    }
    GIVEN("A range size")
    {
        auto end = int64_t{57};
        WHEN("Comparing them to the range with start=0 and step=1")
        {
            THEN("The results must be the same")
            {
                for(auto i: boost::range::combine(range(end), range(0, end, 1)))
                {
                    static_assert(
                            std::is_same<
                                std::decay_t<
                                    decltype(std::get<0>(i))
                                >,
                                int64_t
                            >::value,
                            "Type of the range must be same as type of end");
                    REQUIRE(std::get<0>(i) == std::get<1>(i));
                }

                // // C++17:
                // for(auto [i0, i1]: boost::range::combine(range(end), range(0, end, 1)))
                // {
                //     static_assert(
                //             std::is_same<
                //                 std::decay_t<decltype(i0)>,
                //                 int64_t
                //             >::value,
                //             "Type of the range must be same as type of end");
                //     REQUIRE(i0 == i1);
                // }
            }
        }
    }
}

TEST_CASE("Test remove_if")
{
    GIVEN("An unordered set with a number of odd and even numbers")
    {
        auto uset = std::unordered_set<int32_t>{};
        boost::insert(uset, range(10));

        WHEN("We use erase_if to remove all odd numbers")
        {
            remove_if(uset, [](int32_t i){ return i%2==1; });

            static_assert(std::is_same<decltype(range(uint64_t{255}, int64_t{-1}))::value_type, uint64_t>::value, "wrong");

            for(auto i: range(uset.size(), -1, -1))
            {
                std::cout << i << "\n";
            }

            THEN("Only the even numbers must remain in the set")
            {
                for(auto i: range(10))
                {
                    if(i%2==1)
                    {
                        REQUIRE(uset.count(i) == 0);
                    }
                    else
                    {
                        REQUIRE(uset.count(i) == 1);
                    }
                }
            }
        }
    }
}

TEST_CASE("Test MinNotZero")
{
    GIVEN("Two numbers where one is zero")
    {
        auto n1 = 0;
        auto n2 = 1;
        THEN("MinNotZero should return the nonzero one")
        {
            REQUIRE(MinNotZero{}(n1, n2) == n2);
            REQUIRE(MinNotZero{}(n2, n1) == n2);
        }
    }
    GIVEN("Two numbers where none is zero")
    {
        auto n1 = -1;
        auto n2 = 1;
        THEN("MinNotZero should behave exactly like std::min")
        {
            REQUIRE(MinNotZero{}(n1, n2) == std::min(n1, n2));
            REQUIRE(MinNotZero{}(n2, n1) == std::min(n1, n2));
        }
    }
}

TEST_CASE("Test MinAbs")
{
    GIVEN("Two numbers where one is zero")
    {
        auto n1 = 0;
        auto n2 = 1;
        THEN("MinAbs should return zero")
        {
            REQUIRE(MinAbs{}(n1, n2) == n1);
            REQUIRE(MinAbs{}(n2, n1) == n1);
        }
    }
    GIVEN("Two numbers with different sign")
    {
        auto n1 = -2;
        auto n2 = 1;
        THEN("MinAbs should return zero")
        {
            REQUIRE(MinAbs{}(n1, n2) == 0);
            REQUIRE(MinAbs{}(n2, n1) == 0);
        }
    }
    GIVEN("Two numbers that are both positive")
    {
        auto n1 = 2;
        auto n2 = 1;
        THEN("MinAbs return the smaller one")
        {
            REQUIRE(MinAbs{}(n1, n2) == std::min(n1, n2));
            REQUIRE(MinAbs{}(n2, n1) == std::min(n1, n2));
        }
    }
    GIVEN("Two numbers that are both negative")
    {
        auto n1 = -2;
        auto n2 = -1;
        THEN("MinAbs should return the absolute of the larger one")
        {
            REQUIRE(MinAbs{}(n1, n2) == std::abs(std::max(n1, n2)));
            REQUIRE(MinAbs{}(n2, n1) == std::abs(std::max(n1, n2)));
        }
    }
}
